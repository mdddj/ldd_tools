// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.3.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `dither`, `get_image_byte_data`, `ordered_dither`, `to_monochrome`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `eq`, `fmt`, `from`, `from`, `hash`

///图片转单位色图
/// [`image_buffer`] 图片的字节数据
/// [`width`] 转换后目标宽度
/// [`height`] 转换后的目标高度
/// [`threshold_value`] 将图像阈值化，转换为单色图像程度,一般是 128
/// [`threshold_type`] 阈值化转换逻辑类型, 详见枚举[`LddThresholdType`],默认是Binary
/// [`image_format`] 转换后的目标图片类型, 详见枚举[`LddImageFormat`],默认是bmp
/// [`is_monochrome`] 是否要转黑白图像
Future<BitmapImage> lddCoverImageToLuma8(
        {required List<int> imageBuffer,
        int? width,
        int? height,
        int? thresholdValue,
        LddThresholdType? thresholdType,
        LddImageFormat? imageFormat,
        bool? isMonochrome}) =>
    RustLib.instance.api.crateApiImageLddCoverImageToLuma8(
        imageBuffer: imageBuffer,
        width: width,
        height: height,
        thresholdValue: thresholdValue,
        thresholdType: thresholdType,
        imageFormat: imageFormat,
        isMonochrome: isMonochrome);

///------v2
///把一个图片转换成打印机可以识别的位图
Future<BitmapImage> lddToolsImageToPrinterImage(
        {required List<int> imageBuffer}) =>
    RustLib.instance.api
        .crateApiImageLddToolsImageToPrinterImage(imageBuffer: imageBuffer);

///图片数据
class BitmapImage {
  final Uint8List bitmap;
  final int width;
  final int height;

  const BitmapImage({
    required this.bitmap,
    required this.width,
    required this.height,
  });

  ///转成打印机可识别的tspl命令数据
  /// [`pos`] 打印的x,y位置
  Future<Uint8List> downloadBmpImageTsplCommandData(
          {required (int, int) pos}) =>
      RustLib.instance.api
          .crateApiImageBitmapImageDownloadBmpImageTsplCommandData(
              that: this, pos: pos);

  ///保存到文件
  void saveFile({required String path}) => RustLib.instance.api
      .crateApiImageBitmapImageSaveFile(that: this, path: path);

  @override
  int get hashCode => bitmap.hashCode ^ width.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BitmapImage &&
          runtimeType == other.runtimeType &&
          bitmap == other.bitmap &&
          width == other.width &&
          height == other.height;
}

///image type
enum LddImageFormat {
  png,
  jpeg,
  gif,
  webP,
  pnm,
  tiff,
  tga,
  dds,
  bmp,
  ico,
  hdr,
  openExr,
  farbfeld,
  avif,
  qoi,
  ;

  ///获取对应的扩展名
  String fileExt() => RustLib.instance.api.crateApiImageLddImageFormatFileExt(
        that: this,
      );
}

enum LddThresholdType {
  /// `dst(x,y) = if src(x,y) > threshold { 255 } else { 0 }`
  binary,

  /// `dst(x,y) = if src(x,y) > threshold { 0 } else { 255 }`
  binaryInverted,

  /// `dst(x,y) = if src(x,y) > threshold { threshold } else { src(x,y) }`
  truncate,

  /// `dst(x,y) = if src(x,y) > threshold { src(x,y) } else { 0 }`
  toZero,

  /// `dst(x,y) = if src(x,y) > threshold { 0 } else { src(x,y) }`
  toZeroInverted,
  ;
}
